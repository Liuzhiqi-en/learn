## 并发控制
多用户数据库：允许多个用户同时使用的数据库（订票系统）

不同的多事务执行方式：

* 1.串行执行：每个时刻只有一个事务运行，其他事务必须等到这个事务结束后方能运行。

* 2.交叉并发方式：单处理机系统中，事务的并发执行实际上是这些并行事务的并行操作轮流交叉运行（不是真正的并发，但是提高了系统效率）

* 3.同时并发方式：多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行

并发执行带来的问题：

* 多个事务同时存取同一数据（共享资源）

* 存取不正确的数据，破坏事务一致性和数据库一致性
### 概述
并发操作带来的数据不一致性包括

* 1丢失修改（lost update）
  
* 2不可重复读（non-repeatable read）

* 3读脏数据（dirty read）

并发控制机制的任务：

* 1对并发操作进行正确的调度

* 2保证事务的隔离性

* 3保证数据库的一致性


并发控制的主要技术

* 1封锁（locking）（主要使用的）

* 2时间戳（timestamp）

* 乐观控制法（optimistic scheduler）

* 4多版本并发控制（multi-version concurrency control ，MVCC）
### 封锁
封锁：封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象
#### 1、一级封锁协议
事务T在修改数据R之前，必须先对其加X锁，直到事务结束（commit/rollback）才释放。

一级封锁协议可以防止丢失修改

如果是读数据，不需要加锁的，所以它不能保证可重复读和不读“脏”数据。

#### 2、 二级封锁协议
在一级封锁协议的基础（写要加X锁，事务结束释放）上，增加事务T在读入数据R之前必须先对其加S锁，读完后即可释放S锁。（读要加S锁，读完即释放）

二级封锁协议除了可以防止丢失修改，还可以防止读脏数据

由于读完数据即释放S锁，不能保证不可重复读
#### 3、三级封锁协议
在一级封锁协议基础上增加事务T在读取数据R之前必须先对其加S锁，直到事务结束后释放。

三级封锁协议除了可以防止丢失修改和读脏数据外，还防止了不可重复读
### 饥饿
饥饿：事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后，系统首先批准了T3的请求，T2仍然等待。 T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……T2有可能永远等待，这就是饥饿的情形
避免饥饿的方法：先来先服务

当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队

该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁
### 死锁
死锁：事务T1封锁了数据R1， T2封锁了数据R2。 T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁。 接着T2又申请封锁R1，因T1已封锁了R1，T2也只能

等待T1释放R1上的锁。 这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁。
### 解决死锁的方法：预防、诊断和解除
#### 1、死锁的预防

产生死锁的原因是两个或多个事务都已经封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待。

预防死锁发生就是破坏产生死锁的条件
##### 方法
1）一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

存在的问题：降低系统的并发度；难以实现精确确定封锁对象

2）顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。

存在的问题：维护成本：数据库系统中的封锁对象极多，并且在不断地变化难以实现：很难实现确定每一个事务要封锁哪些对象

DBMS普通采用的诊断并解除死锁的方法
#### 2、死锁的诊断和解除
##### 方法：超时法和事务等待图法
1）超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁

优点：实现简单

缺点：误判死锁；时限若设置太长，死锁发生后不能及时发现。

2）事务等待图法：用事务等待图动态反映所有事务的等待情况事务

等待图是一个有向图G=(T，U)，T为结点的集合，每个结点表示正运行的事务， U为边的集合，每条边表示事务等待的情况。若T1等待T2，则T1、T2之间划一条有向边，从T1指向T2。

并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。    

解除死锁：并发控制子系统选择一个处理死锁代价最小的事务，将其撤销。

释放该事务持有的所有的锁，使其他事务能够继续运行下去。
### 串行调度
执行结果等价于串行调度的调度也是正确的，这样的调度称为可串行化调度
可串行化调度

定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化调度（serializable）。

可串行性是并发事务正确调度的准则。按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

冲突可串行化调度

判断可串行化调度的充分条件

冲突操作：不同的事务对同一个数据的读写和写写操作。
不同事务的冲突操作和同一事务的两个操作是不能交换的。

Ri（x）和Wj（x）不可交换，Wi（x）和Wj（x）不可交换（x为事务）

冲突可串行化调度：

一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc为冲突可串行化的调度。
### 两段锁协议
DBMS的并发控制机制必须提供一定的手段来保证调度是可串行化的。目前DBMS普遍采用两段锁协议（TwoPhase Locking，简称2PL）的方法来显示并发调度的可串行性。
两段锁协议是指所有事务必须分两个阶段对数据对象进行加锁和解锁。

* 1在对任何数据进行读写操作以前，首先要申请并获得对该数据的锁。

* 2在释放一个锁之后，事务不再申请和获得其他任何的锁。

#### “两段”锁的含义：事务分为两个阶段

第一阶段是获得封锁，也称为扩展阶段

事务可以申请获得任何数据对象上的任何类型的锁，但是不能释放任何锁

第二阶段是释放封锁，也称为收缩阶段

事务可以释放任何数据对象上的任何类型的锁，但是不能再申请任何锁

 

事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。

若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的

若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议

 

#### 两段锁协议与防止死锁的一次封锁法

一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议

但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁
### 封锁的粒度
封锁对象的大小称为封锁粒度（granularity）。

封锁的对象可以是逻辑单元（属性值、属性值集合、元组、关系、索引项、数据库），也可以是物理单元（页、物理记录）。

选择封锁粒度原则：

* 封锁粒度和系统的并发度和并发控制的开销密切相关

* 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越低，系统开销也越小；

封锁的粒度越小，并发度较高，但系统开销也就越大
### 意向锁
意向锁：如果对一个节点加意向锁，则可说明该节点的下层节点正在被加锁；对任一节点加锁时，必须先对它的上层节点加意向锁。

例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁。

三种常用的意向锁：意向共享锁（Intent Share Lock，IS锁）；意向排它锁（Intent Exclusive Lock，IX锁）；共享意向排它锁（Share Intent Exclusive Lock，SIX锁）。
* 1、IS锁
如果对一个数据对象加IS锁，表示它的子节点拟加S锁。
例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁
* 2、IX锁如果对一个数据对象加IX锁，表示它的子节点拟加X锁。
例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁
* 3、SIX锁
如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。
例如：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）

意向锁的强度： 锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。

具有意向锁的多粒度封锁方法

申请封锁时应该按自上而下的次序进行

释放封锁时则应该按自下而上的次序进行

优点：

* 提高了系统并发度

* 减少了加锁和解锁的开销

在实际的DBMS产品中得到广泛应用。
### 其他并发控制
并发控制的方法除了封锁技术外，还有时间戳方法、乐观控制法和多版本并发控制。

时间戳方法：给每一个事务盖上一个时标，即事务开始的时间。每个事务具有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。如果发生冲突操作，就回滚到具有较早时间戳的事务，以保证其他事务的正常执行，被回滚的事务被赋予新的时间戳被从头开始执行。

乐观控制法认为事务执行时很少发生冲突，所以不对事务进行特殊的管制，而是让它自由执行，事务提交前再进行正确性检查。如果检查后发现该事务执行中出现过冲突并影响了可串行性，则拒绝提交并回滚该事务。又称为验证方法

多版本控制是指在数据库中通过维护数据对象的多个版本信息来实现高效并发的一种策略。