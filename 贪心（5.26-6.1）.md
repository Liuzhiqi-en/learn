# 贪心

## 🍈介绍

贪心算法是一种在每一步选择中都力图使局部最优解能够逐步达到全局最优解的算法。与其他算法不同的是，贪心算法在选择过程中不进行回溯，选择的过程往往基于某种局部最优策略。在一些特定的问题中，贪心算法可以通过逐步构建最优解来实现全局最优。

### 🍈贪心算法的基本原理

贪心算法的核心思想是通过一系列局部最优选择来构建全局最优解。

### 🍈步骤

#### 🍍选择初始状态

确定算法的起点。

#### 🍍应用贪心选择性

在当前状态下选择一个局部最优的动作，以期望能达到全局最优。

#### 🍍检查算法的可行性

判断当前选择是否满足问题的约束条件。

#### 🍍更新状态

根据贪心选择的结果更新当前状态。

#### 🍍结束条件

检查是否达到算法的结束条件。



### 121.买卖股票最佳时间

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int x=prices.size();
        int min=prices[0],maxprices=0;
        for(int i=0;i<x;i++){
            int t=0;
            if(min>prices[i]){
                min=prices[i];
            }
            t=prices[i]-min;
            if(maxprices<t){
                maxprices=t;
            }

        }
        return maxprices;
    }
};
```

使用for循环，每天维护前面的最低价格，计算今日价格与之前最低价格的差，然后判断是否是最多的。初始为0。

时间复杂度O(n),空间O(1)。

### 55.跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int x=nums.size();
        int n=nums[0];
        bool flag=true;
        for(int i=0;i<x;i++){
            if(i==x-1){
                break;
            }
            if(nums[i]>n){
                n=nums[i];
                
            }
            
            if(n==0){
                flag=false;
                break;
            }
            n--;
        }
        return flag;
    }
};
```

简单来说就是每个都走一遍，因为该题不用算步数，所以我只要维护我最大能走几步，如果该数据大于我之前数据，我就更新数据，然后判断步数是不是为0，为0就相当于“死”在这一步，过不去了，因为我一直是前面能走最大的距离。这道题可以很好的看出来从局部最优到整体最优。

时间复杂度O(n),空间O(1)。

### 45.跳跃游戏2

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

 

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int x=nums.size();
        int maxdis=0;
        int nextmax=0;
        int m=0;
        for(int i=0;i<x-1;i++){
            nextmax=max(nextmax,i+nums[i]);
            if(i==maxdis){
                maxdis=nextmax;
                m++;
            }
        }
        return m;
    }
};
```

这道题是之前的变式，现在需要看步数，我们需要看下一步最远能到哪里，每次循环都跟新next能到哪里，因为题目保证一定能到，所以我们不用考虑，直接最远，步数最少，同时注意循环直到x-1，也就是最后一个不遍历，要不然m会多一。

时间复杂度O(n),空间O(1)。

### 763.划分字母区间

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

 

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**示例 2：**

```
输入：s = "eccbbbbdec"
输出：[10]
```

 

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int hash[27]={0};
        for(int i=0;i<s.size();i++){
            hash[s[i]-'a']=i;
        }
        vector<int>res;
        int left=0;
        int right=0;
        for(int i=0;i<s.size();i++){
            right=max(right,hash[s[i]-'a']);
            if(i==right){
                res.push_back(right-left+1);
                left=i+1;
            }
        }
        return res;
    }
};
```

使用hash来转载每个字母的最大下标，然后right从头开始，与之前的最大下标维护，当找到了下标与right一致时即可push出来，然后left维护一下![image-20250601160022951](C:\Users\刘志麒\AppData\Roaming\Typora\typora-user-images\image-20250601160022951.png)

时间复杂度O(n),空间O(1)。

### 🍉贪心算法的优缺点

#### 🍈优点🍈

简单易懂：

贪心算法通常非常直观和易于理解，解决问题的思路简单直接。
局部最优解：

贪心算法通过每一步选择当前最优解（局部最优解），尝试构建全局最优解。
高效：

贪心算法的时间复杂度通常较低，适合解决某些大规模问题。常见的时间复杂度为 O(n log n) 或 O(n)。
应用广泛：

贪心算法在诸如图论（如最小生成树、最短路径）、任务调度、资源分配等多个领域有广泛的应用。

#### 🍈缺点🍈

局限性：

贪心算法并不总能找到问题的最优解。它依赖于每一步的局部最优选择，可能会错过全局最优解。例如，背包问题的贪心算法不能保证找到最优解。
问题依赖性：

贪心算法只有在某些特定类型的问题（满足贪心选择性质和最优子结构性质）中才能有效工作。对于不满足这些性质的问题，贪心算法无法保证最优解。
分析复杂：

对于某些问题，证明贪心算法的正确性和最优性可能较为复杂，需要仔细的数学推导和验证。
无回溯：

贪心算法一旦做出选择，就不会回溯或改变决定。因此，一旦做出错误的选择，就无法修正。

#### 🍈适用问题的特性🍈

为了确保贪心算法能够找到问题的最优解，需要满足以下特性

贪心选择性质：

在每一步选择中，局部最优解可以导向全局最优解。即当前的贪心选择不影响问题的整体最优性。
最优子结构性质：

一个问题的最优解包含其子问题的最优解。即问题可以分解成若干子问题，子问题的最优解组合成原问题的最优解。